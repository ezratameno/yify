package main

import (
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"

	"github.com/ezratameno/yify/business/data/store/movie"
)

const fileType string = ".torrent"

// Resource represents a single binary resource, such as an image or font.
// A resource has an identifying name and byte array content.
// The serialised path of a resource can be obtained which may result in a
// blocking filesystem write operation.
type Resource interface {
	Name() string
	Content() []byte
}

// StaticResource is a bundled resource compiled into the application.
// These resources are normally generated by the fyne_bundle command included in
// the Fyne toolkit.
type StaticResource struct {
	StaticName    string
	StaticContent []byte
}

// Name returns the unique name of this resource, usually matching the file it
// was generated from.
func (r *StaticResource) Name() string {
	return r.StaticName
}

// Content returns the bytes of the bundled resource, no compression is applied
// but any compression on the resource is retained.
func (r *StaticResource) Content() []byte {
	return r.StaticContent
}

// NewStaticResource returns a new static resource object with the specified
// name and content. Creating a new static resource in memory results in
// sharable binary data that may be serialised to the location returned by
// CachePath().
func NewStaticResource(name string, content []byte) *StaticResource {
	return &StaticResource{
		StaticName:    name,
		StaticContent: content,
	}
}

// LoadResourceFromURLString creates a new StaticResource in memory using the body of the specified URL.
func loadResourceFromURLString(urlStr string) (Resource, error) {
	res, err := http.Get(urlStr)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	bytes, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	name := filepath.Base(urlStr)
	return NewStaticResource(name, bytes), nil
}

func Download(movie movie.Movie, link string) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return err
	}
	filePath := home + "/Downloads/"
	if runtime.GOOS == "windows" {
		filePath = filepath.FromSlash(filePath)
	}
	err = DownloadFile(filePath+movie.Name+fileType, link)
	if err != nil {
		return nil
	}
	err = openTorrentFile(movie.Name)
	if err != nil {
		return err
	}
	return nil
}

func openTorrentFile(movieName string) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return err
	}
	filePath := home + "/Downloads/"
	cmd := exec.Command("rundll32.exe", "url.dll,FileProtocolHandler", filePath+movieName+fileType)
	cmd.Start()
	return nil
}

func DownloadFile(filepath string, url string) error {
	// Get the data
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Create the file
	out, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer out.Close()

	// Write the body to file
	_, err = io.Copy(out, resp.Body)
	return err
}
